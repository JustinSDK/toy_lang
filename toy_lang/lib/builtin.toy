exports = ['Exception', 'println', 'iterate', 'range', 'isInstance']

class Exception(Traceable) {
    def init() {
        this.super(Traceable, 'init', arguments)
    }
}

def println(message) {
    if hasValue(message) {
        print(message)
    }
    print('\n')
}

def iterate(start, stop, step) {
    n = start
    p = stop if isInstance(stop, Function) else (i -> i < stop)
    s = step if isInstance(step, Function) else (i -> i + (step if hasValue(step) else 1))

    class Iter {
        def hasNext() {
            return p(n)
        }

        def next() {
            v = n
            nonlocal n = s(n)
            return v
        }

        def forEach(action) {
            while this.hasNext() {
                action(this.next())
            }
        }            
    }

    return new Iter()
}

def range(start, stop, step) {
    lt = []
    iterate(start, stop, step).forEach(n -> lt.add(n))
    return lt
}

def isSubType(clz, parentClz) {
    if clz == Object {
        return false
    }

    parentClzs = clz.parents()
    if parentClzs.any(c -> c == parentClz) {
        return true
    }

    return parentClzs.any(c -> isSubType(c, parentClz))
}

def isInstance(obj, type) {
    if hasValue(obj) and notPrimitive(obj) {
        clz = obj.class()
        return (clz == type) or isSubType(clz, type)
    }
    return false
}

primitives = ['number', 'string', 'boolean']
def notPrimitive(v) {
    return not primitives.includes(typeof(v))
}

